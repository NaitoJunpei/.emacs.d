package SulabApplet1;
//カルマンフィルタ and スムージング
//time-dependent-poisson(kappa=1と固定)
//書き方やアルゴリズムはKalmanFilter8.javaと同じ（kappa=1,beta=1/(2*gamma^2)としてκの次元を落として考えればよい）
public class KalmanFilter_tdp2_1{
	
	static double[] T;
	static int N;
	
	static double[][] EL;//lambdaの推定平均. EL[0][i]=EL(i/i) , EL[1][i]=EL(i+1/i)
	static double[][] VL;//lambdaの推定分散. VL[0][i]=VL(i/i) , VL[1][i]=VL(i+1/i)
	static double[] EL_N;//lambdaの推定平均. データはN番目まで与えられたものとする. EL_N[i]=EL(i/N). 
	static double[] VL_N;//lambdaの推定分散. データはN番目まで与えられたものとする. VL_N[i]=VL(i/N). 
	static double[] COVL_N;//lambdaの推定共分散. データはN番目まで与えられたものとする. COVL_N[i]=COVL(i+1,i/N).
	static double[] H;
	
	static double A;
	
	public static void Initialize (double[] t){
		T = t;
		N = T.length;
		
		EL = new double[2][N];
		VL = new double[2][N];
		EL_N = new double[N];
		VL_N = new double[N];
		COVL_N = new double[N];
		H = new double[N];
		
		///初期値設定///
		//lambdaの初期値のため、Tの平均をとる
		double mu = 0;
		for(int i=0;i<N;i++){
			mu += T[i];
		}
		mu = N/mu;
		//filtering
		double IEL = mu;//データなしでの予測値(平均)
		double IVL = (mu/3)*(mu/3);//データなしでの予測値(分散)
		A = IEL - T[0]*IVL;
		EL[0][0]=(A+Math.sqrt(A*A+4*IVL))/2; //二次方程式の解の公式
		VL[0][0]=1/(1/IVL+1/(EL[0][0]*EL[0][0]));
	}
	
	public static double[][] KalmanFilter (double beta) {
		//prediction and filtering
		for(int i=0;i<N-1;i++){
			//prediction
			EL[1][i]=EL[0][i];
			VL[1][i]=VL[0][i]+T[i]/(2*beta);
			//filtering
			A = EL[1][i]-T[i+1]*VL[1][i];
			EL[0][i+1]=(A+Math.sqrt(A*A+4*VL[1][i]))/2; //二次方程式の解の公式
			VL[0][i+1]=1/(1/VL[1][i]+1/(EL[0][i+1]*EL[0][i+1]));
		}
		
		//smoothing
		EL_N[N-1] = EL[0][N-1]; //データはN番目まで与えられている。定義により。
		VL_N[N-1] = VL[0][N-1];
		for(int i=N-2;i>=0;i--){
			H[i]=VL[0][i]/VL[1][i];
			
			EL_N[i]=EL[0][i]+H[i]*(EL_N[i+1]-EL[1][i]);
			VL_N[i]=VL[0][i]+H[i]*H[i]*(VL_N[i+1]-VL[1][i]);
			COVL_N[i]=H[i]*VL_N[i+1];
		}
		
		double[][] data = new double[3][N];//返値
		//data[0][*]=EL_N[*], data[1][*]=VL_N[*], data[2][*]=COVL_N[i]
		for(int i=0;i<N;i++){
			data[0][i]=EL_N[i];
			data[1][i]=VL_N[i];
			data[2][i]=COVL_N[i];
		}
		
		return data;
	}

}