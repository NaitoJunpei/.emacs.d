//スパイク列から発火率(rate or λ)を求めるプログラム

import java.applet.*;
import javax.swing.JApplet.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.awt.Color;
import SulabApplet1.*;

public class SulabApplet1 extends Applet{
	SulabApplet1 Ex;
	DrawPanel_SulabApplet1 DP;
	static KalmanFilter_tdp2_1 KF;
	static EMmethod_tdp2_1 EM;
	static NonGaussianFilter_tdp2_1 NGF;
	static NonGaussianEMmethod_tdp2_1 NGEM;
	
	static double DATA[]; //スパイク発火時刻の値
	static double ISI[]; //interspike intervalの値
	int data_length; //スパイクの数
	int x_left; //最初のスパイク時刻より少し前の切りの良い数字にあたる時刻
	int x_right; //最後のスパイク時刻より少し後の切りの良い数字にあたる時刻
	int y_range; //描画する発火率の上限
	int n;	// 10^n < x < 10^(n+1)
	double beta0 = 77; //ハイパーパラメータの初期値
	double beta = 1; //ハイパーパラメータ
	
	public void DataLength(int i) {
		data_length = i;
		DATA = new double [data_length]; //スパイク発火時刻の値
		ISI = new double [data_length-1]; //interspike intervalの値
	}
	public void InputData(int i, float data) {
		DATA[i] = data;
	}
	public void StartJava() {
		for(int i=0;i<data_length-1;i++){
			ISI[i] = DATA[i+1] - DATA[i]; //スパイク発火時刻からinterspike intervalを求める
		}
		DP.t = DATA;
		DP.T = ISI;
		
		n = 0; //描画の参考のため、データの範囲が10^n〜10^(n+1)で収まるようなnを求める
		if((DATA[data_length-1]-DATA[0])>1){
			while((DATA[data_length-1]-DATA[0])>Math.pow(10,n+1)){
				n += 1;
			}
		}else{
			while((DATA[data_length-1]-DATA[0])<Math.pow(10,n)){
				n -= 1;
			}
		}
		if(DATA[0]>0){ //nを参考に、最初の時刻より少し前の切りの良い数字にあたる時刻を描画の左端とする
			x_left = (int)(DATA[0]*Math.pow(10,1-n)); //intにより小数点以下を切り捨て
		}else{
			x_left = (int)(DATA[0]*Math.pow(10,1-n))-1;
		}
		DP.x_left = (double)x_left/Math.pow(10,1-n);
		if(DATA[data_length-1]>0){ //nを参考に、最後の時刻より少し後の切りの良い数字にあたる時刻を描画の右端とする
			x_right = (int)(DATA[data_length-1]*Math.pow(10,1-n))+1;
		}else{
			x_right = (int)(DATA[data_length-1]*Math.pow(10,1-n));
		}
		DP.x_right = (double)x_right/Math.pow(10,1-n);
		
		DP.y_range = (double)data_length/(DATA[data_length-1]-DATA[0])*2; //縦軸である発火率の範囲は平均発火率の2倍を参考にする
		n = 0; //描画の参考のため、同様にy_rangeが10^n〜10^(n+1)で収まるようなnを求める
		if(DP.y_range>1){
			while(DP.y_range>Math.pow(10,n+1)){
				n += 1;
			}
		}else{
			while(DP.y_range<Math.pow(10,n)){
				n -= 1;
			}
		}
		y_range = (int)(data_length/(DATA[data_length-1]-DATA[0])*2*Math.pow(10,1-n))+1;
		DP.y_range = (double)y_range/Math.pow(10,1-n); //nを参考に、y_rangeより少し大きい切りの良い値を描画の上端とする
		DP.stage = 1; //描画（ラスタープロット）を行う
		DP.repaint();
	}
	public void SecondStage() { //カルマンフィルタにより発火率を推定して描画
		DP.xPoints2 = new int[data_length-1]; //発火率の推定値（カルマンフィルタ）に対応する時刻の格納場所を準備
		DP.yPoints2 = new int[data_length-1]; //発火率の推定値（カルマンフィルタ）の格納場所を準備
		double mu = data_length/(DATA[data_length-1]-DATA[0]); //平均発火率
		beta0 = Math.pow(mu,-3); //平均発火率を参考にハイパーパラメータの初期値を定める
		EM.Initialize(ISI,beta0); //データとハイパーパラメータ初期値をEMアルゴリズムに渡す
		beta = EM.EMmethod(); //EMアルゴリズムで求まったハイパーパラメータを受け取る
		DP.kalman_data = KF.KalmanFilter(beta); //求まったハイパーパラメータを用いてカルマンフィルタにより発火率を推定
		DP.stage = 2; //推定された発火率の描画を行う
		DP.repaint();
	}
	public void ThirdStage() { //非ガウスフィルタにより発火率を推定して描画
		NGEM.Initialize(ISI,beta); //データとハイパーパラメータ初期値をEMアルゴリズムに渡す
		beta = NGEM.EMmethod(); //EMアルゴリズムで求まったハイパーパラメータを受け取る
		DP.nongaussian_data = NGF.NonGaussianFilter_tdp(beta); //求まったハイパーパラメータを用いて非ガウスフィルタにより発火率を推定
		DP.D = NGF.D; //非ガウスフィルタにおける時刻数（カルマンフィルタより細かくとる）
		DP.xPoints3 = new int[DP.D]; //発火率の推定値（非ガウスフィルタ）に対応する時刻の格納場所を準備
		DP.yPoints3 = new int[DP.D]; //発火率の推定値（非ガウスフィルタ）の格納場所を準備
		DP.dt = NGF.dt; //非ガウスフィルタにおける時間幅
		DP.stage = 3; //推定された発火率の描画を行う
		DP.repaint();
	}
	
	public SulabApplet1(){
		DP = new DrawPanel_SulabApplet1(this);
		setLayout(new BorderLayout());
		add(DP,BorderLayout.CENTER);
	}
	public void init(){
		new SulabApplet1();
	}
	public static void main(String args[]){
		SulabApplet1 extdp = new SulabApplet1();
		JFrame frame = new JFrame("SulabApplet1");
		Container c = frame.getContentPane();
		c.add(extdp);
		frame.pack();
		frame.setVisible(true);
		frame.addWindowListener(new WindowAdapter(){
			public void windowClosing(WindowEvent e){
				System.exit(0);
			}
		});
	}
	
	double outputdata;
	int temp_outputdata;
	public double OutputTimeKalman(int i){ //発火率の推定値（カルマンフィルタ）に対応する時刻を出力
		outputdata = (DATA[i+1]+DATA[i])/2;
		n = 0; //出力データの有効数字の桁数の調整のため
		if(Math.abs(outputdata)>1){
			while(Math.abs(outputdata)>Math.pow(10,n+1)){
				n += 1;
			}
		}else{
			while(Math.abs(outputdata)<Math.pow(10,n)){
				n -= 1;
			}
		}
		temp_outputdata = (int)(outputdata*Math.pow(10,4-n));
		outputdata = (double)temp_outputdata/Math.pow(10,4-n);
		return outputdata;
	}
	public double OutputRateKalman(int i){ //発火率の推定値（カルマンフィルタ）を出力
		outputdata = DP.kalman_data[0][i];
		n = 0; //出力データの有効数字の桁数の調整のため
		if(Math.abs(outputdata)>1){
			while(Math.abs(outputdata)>Math.pow(10,n+1)){
				n += 1;
			}
		}else{
			while(Math.abs(outputdata)<Math.pow(10,n)){
				n -= 1;
			}
		}
		temp_outputdata = (int)(outputdata*Math.pow(10,4-n));
		outputdata = (double)temp_outputdata/Math.pow(10,4-n);
		return outputdata;
	}
	public int OutputNumNonGaussian(){
		return DP.D;
	}
	public double OutputTimeNonGaussian(int i){ //発火率の推定値（非ガウスフィルタ）に対応する時刻を出力
		outputdata = DATA[0]+DP.dt*(i+0.5);
		n = 0; //出力データの有効数字の桁数の調整のため
		if(Math.abs(outputdata)>1){
			while(Math.abs(outputdata)>Math.pow(10,n+1)){
				n += 1;
			}
		}else{
			while(Math.abs(outputdata)<Math.pow(10,n)){
				n -= 1;
			}
		}
		temp_outputdata = (int)(outputdata*Math.pow(10,4-n));
		outputdata = (double)temp_outputdata/Math.pow(10,4-n);
		return outputdata;
	}
	public double OutputRateNonGaussian(int i){ //発火率の推定値（非ガウスフィルタ）を出力
		outputdata = DP.nongaussian_data[i];
		n = 0; //出力データの有効数字の桁数の調整のため
		if(Math.abs(outputdata)>1){
			while(Math.abs(outputdata)>Math.pow(10,n+1)){
				n += 1;
			}
		}else{
			while(Math.abs(outputdata)<Math.pow(10,n)){
				n -= 1;
			}
		}
		temp_outputdata = (int)(outputdata*Math.pow(10,4-n));
		outputdata = (double)temp_outputdata/Math.pow(10,4-n);
		return outputdata;
	}
}


class DrawPanel_SulabApplet1 extends JPanel{ //描画関係
	private SulabApplet1 extdpApplet_;
	int width = 450;
	int w_interval = 50;
	int height = 200;
	int h_interval = 50;
	
	DrawPanel_SulabApplet1(SulabApplet1 extdp){
		this.extdpApplet_ = extdp;
		setBackground(Color.white);
		setMinimumSize(new Dimension(width+2*w_interval, height+2*h_interval-20));
		setPreferredSize(new Dimension(width+2*w_interval,height+2*h_interval-20));
	}
	
	static double x_left = 0;
	static double x_right = 200;
	static double y_range = 2;
	int X (double x){
		return (int)((x-x_left)/(x_right-x_left)*width+w_interval);
	}
	int Y (double y){
		return (int)((y_range-y)/y_range*height+h_interval-20);
	}
	
	int[] xPoints2;//lambda推定値(kalman)
	int[] yPoints2;
	int[] xPoints3;//lambda推定値(NonGaussian)
	int[] yPoints3;
	int D = 0;
	double dt = 1;
	
	static int stage = 0;
	
	double[] T;
	double[] t;
	
	double[][] kalman_data;
	double[] nongaussian_data;
	
	public void paintComponent(Graphics g){ //段階に応じて描画内容を指示
		super.paintComponent(g);
		g.drawRect(X(x_left),Y(y_range),X(x_right)-X(x_left),Y(0)-Y(y_range));
		g.drawString("time",X((x_right-x_left)/2)-10,Y(0)+40);
		g.drawLine(X(x_left),Y(0),X(x_left),Y(y_range));
		g.drawString("rate",X(x_left)-48,Y(y_range/2)-50);
		
		if(stage>0){ //目盛りやスパイクラスターを表示
			//timeの目盛
			g.drawLine(X(x_left),Y(0),X(x_left),Y(0)+5);
			g.drawString(""+x_left,X(x_left)-10,Y(0)+20);
			g.drawLine(X((x_right+x_left)/2),Y(0),X((x_right+x_left)/2),Y(0)+5);
			g.drawString(""+((x_right+x_left)/2),X((x_right+x_left)/2)-10,Y(0)+20);
			g.drawLine(X(x_right),Y(0),X(x_right),Y(0)+5);
			g.drawString(""+x_right,X(x_right)-10,Y(0)+20);
			//rateの目盛
			g.drawLine(X(x_left)-5,Y(0),X(x_left),Y(0));
			g.drawString("0",X(x_left)-30,Y(0)+5);
			g.drawLine(X(x_left)-5,Y(y_range/2),X(x_left),Y(y_range/2));
			g.drawString(""+(y_range/2),X(x_left)-30,Y(y_range/2)+5);
			g.drawLine(X(x_left)-5,Y(y_range),X(x_left),Y(y_range));
			g.drawString(""+y_range,X(x_left)-30,Y(y_range)+5);
			//スパイクラスター
			g.setColor(new Color(255,0,0));
			for(int i=0;i<t.length;i++){
				g.drawLine(X(t[i]),Y(0),X(t[i]),Y(0)-15);
			}
		}
		if(stage>=2){ //カルマンフィルタで推定された発火率を描画
			g.setColor(new Color(0,0,255));
			for(int i=0;i<xPoints2.length;i++){
				xPoints2[i]=X(t[i]/2+t[i+1]/2);
				yPoints2[i]=Y(kalman_data[0][i]);
			}
			g.drawPolyline(xPoints2,yPoints2,xPoints2.length);
		}
		if(stage==3){ //非ガウスフィルタで推定された発火率を描画
			g.setColor(new Color(0,191,0));
			for(int i=0;i<D;i++){
				xPoints3[i]=X(t[0]+dt*(i+0.5));
				yPoints3[i]=Y(nongaussian_data[i]);
			}
			g.drawPolyline(xPoints3,yPoints3,D);
		}
		
		g.setColor(new Color(255,255,255));
		g.fillRect(X(x_right)+1,0,w_interval-1,height+h_interval-20);
	}
}
